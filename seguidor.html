<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HandDraw Pro — Profissional</title>

<!-- Bootstrap + Icons -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

<style>
:root{
  --bg-dark: #071226;
  --glass: rgba(12,18,30,0.6);
  --accent: #7dd3fc;
  --muted: #9fb9da;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-dark),#020617);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8}
.app{display:flex;gap:16px;height:100vh;padding:18px}
.stage{flex:1;position:relative;border-radius:12px;overflow:hidden;background:#000;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:contrast(1.02) saturate(1.05);}
canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
.panel{width:380px;backdrop-filter:blur(8px);background:var(--glass);border-radius:12px;padding:14px;display:flex;flex-direction:column;gap:10px}
.title{font-weight:700;font-size:18px}
.status{font-size:13px;color:var(--muted)}
.hud-dot{position:absolute;width:26px;height:26px;border-radius:50%;transform:translate(-50%,-50%);pointer-events:none}
.small{font-size:13px}
.controls .btn{min-width:110px}
.toggle-theme{cursor:pointer}
/* neon stroke shadow for canvas */
.neon {
  filter: drop-shadow(0 0 8px rgba(125,211,252,0.22)) drop-shadow(0 0 12px rgba(125,211,252,0.08));
}
/* responsive */
@media(max-width:920px){
  .panel{width:300px}
}
</style>
</head>
<body>
<div class="app">
  <div class="stage" id="stage">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="draw" class="neon"></canvas>
    <canvas id="hud"></canvas>

    <div style="position:absolute;left:12px;bottom:12px;z-index:50;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px">
      <span class="small">Status:</span> <strong id="statusText">Iniciando...</strong>
    </div>
  </div>

  <div class="panel">
    <div class="d-flex justify-content-between align-items-start">
      <div>
        <div class="title"><i class="bi bi-brush"></i> HandDraw Pro</div>
        <div class="status">Desenho por movimento da mão — avançado</div>
      </div>
      <div>
        <button id="themeToggle" class="btn btn-sm btn-outline-light" title="Alternar tema"><i class="bi bi-circle-half"></i></button>
      </div>
    </div>

    <div class="row g-2 align-items-center">
      <div class="col-auto">
        <label class="form-label small mb-0">Cor</label>
        <input id="color" type="color" class="form-control form-control-color" value="#7dd3fc" style="width:64px;height:40px;padding:0">
      </div>
      <div class="col">
        <label class="form-label small mb-0">Tamanho: <span id="thickVal">8</span>px</label>
        <input id="thickness" type="range" class="form-range" min="1" max="120" value="8">
      </div>
    </div>

    <div class="d-flex gap-2 align-items-center">
      <div class="form-check form-switch">
        <input id="pinchToggle" class="form-check-input" type="checkbox" checked>
        <label class="form-check-label small" for="pinchToggle">Pinçar para desenhar</label>
      </div>
      <div class="form-check form-switch ms-2">
        <input id="mirrorToggle" class="form-check-input" type="checkbox" checked>
        <label class="form-check-label small" for="mirrorToggle">Espelhar X</label>
      </div>
    </div>

    <div class="controls d-flex gap-2 flex-wrap">
      <button id="eraserBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-eraser"></i> Borracha</button>
      <button id="undoBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-arrow-counterclockwise"></i> Undo</button>
      <button id="redoBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-arrow-clockwise"></i> Redo</button>
      <button id="clearBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-trash"></i> Limpar</button>
      <button id="savePngBtn" class="btn btn-primary btn-sm"><i class="bi bi-download"></i> Salvar PNG</button>
      <button id="saveSvgBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-filetype-svg"></i> Exportar SVG</button>
      <button id="replayBtn" class="btn btn-outline-light btn-sm"><i class="bi bi-play-fill"></i> Replay</button>
    </div>

    <div class="mt-auto small text-muted">
      Dicas: <strong>Pinça</strong> para desenhar. <strong>Mão aberta</strong> pausa; feche a mão (1s) para limpar.
    </div>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
const video = document.getElementById('cam');
const drawCanvas = document.getElementById('draw');
const hudCanvas = document.getElementById('hud');
const ctx = drawCanvas.getContext('2d', { alpha:true });
const hud = hudCanvas.getContext('2d', { alpha:true });

const statusText = document.getElementById('statusText');
const colorEl = document.getElementById('color');
const thicknessEl = document.getElementById('thickness');
const thickVal = document.getElementById('thickVal');
const pinchToggle = document.getElementById('pinchToggle');
const mirrorToggle = document.getElementById('mirrorToggle');

const eraserBtn = document.getElementById('eraserBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const clearBtn = document.getElementById('clearBtn');
const savePngBtn = document.getElementById('savePngBtn');
const saveSvgBtn = document.getElementById('saveSvgBtn');
const replayBtn = document.getElementById('replayBtn');
const themeToggle = document.getElementById('themeToggle');

let cameraObj = null;
let running = false;
let erasing = false;
let prevPoint = null;
let prevHud = null;
let currentStroke = null;
let closedStartTime = null;

const undoStack = [];
const redoStack = [];
const MAX_HISTORY = 20;
const strokes = [];
let lastTime = 0;
let darkTheme = true;
// keep history as snapshots of the vector strokes for consistent undo/redo
let currentMirrorState = mirrorToggle.checked;

/* Resize canvases */
function resizeCanvases(){
  const rect = document.getElementById('stage').getBoundingClientRect();
  const ratio = window.devicePixelRatio || 1;
  const newW = Math.floor(rect.width * ratio);
  const newH = Math.floor(rect.height * ratio);

  // resize internal buffer to device pixels and keep CSS size in CSS pixels
  const oldW = drawCanvas.width, oldH = drawCanvas.height;
  drawCanvas.width = newW; drawCanvas.height = newH;
  hudCanvas.width = newW; hudCanvas.height = newH;

  drawCanvas.style.width = rect.width + 'px';
  drawCanvas.style.height = rect.height + 'px';
  hudCanvas.style.width = rect.width + 'px';
  hudCanvas.style.height = rect.height + 'px';

  const scale = ratio;
  ctx.setTransform(scale,0,0,scale,0,0);
  hud.setTransform(scale,0,0,scale,0,0);

  // redraw vector strokes at the new size
  redrawAll();
}
window.addEventListener('resize', resizeCanvases);

/* UI wiring */
thicknessEl.addEventListener('input', ()=> thickVal.textContent = thicknessEl.value);
eraserBtn.addEventListener('click', ()=> {
  erasing = !erasing;
  eraserBtn.classList.toggle('btn-primary', erasing);
  eraserBtn.innerHTML = erasing ? '<i class="bi bi-eraser"></i> Borracha' : '<i class="bi bi-brush"></i> Desenhar';
});
clearBtn.addEventListener('click', ()=> { pushHistory(); strokes.length=0; redrawAll(); });
undoBtn.addEventListener('click', undoAction);
redoBtn.addEventListener('click', redoAction);
savePngBtn.addEventListener('click', savePNG);
saveSvgBtn.addEventListener('click', exportSVG);
replayBtn.addEventListener('click', startReplay);
themeToggle.addEventListener('click', toggleTheme);

// mirror visual sync
function applyMirrorVisual(){
  // visually flip the video
  video.style.transform = mirrorToggle.checked ? 'scaleX(-1)' : 'none';
  // if mirror state changed, flip stored stroke coordinates so they stay aligned
  if(currentMirrorState !== mirrorToggle.checked){
    // flip all stroke x coordinates in-place
    for(const s of strokes){
      if(!s.points) continue;
      for(const p of s.points){
        p.x = drawCanvas.width - p.x;
      }
    }
    // also flip prevHud if present
    if(prevHud) prevHud.x = drawCanvas.width - prevHud.x;
    currentMirrorState = mirrorToggle.checked;
    redrawAll();
  }
}
mirrorToggle.addEventListener('change', applyMirrorVisual);
applyMirrorVisual();

/* Helpers */
function pushHistory(){
  // store shallow clone of strokes (deep clone to be safe)
  if(undoStack.length >= MAX_HISTORY) undoStack.shift();
  undoStack.push(JSON.parse(JSON.stringify(strokes)));
  redoStack.length = 0;
}
function undoAction(){
  if(!undoStack.length) return;
  redoStack.push(JSON.parse(JSON.stringify(strokes)));
  const prev = undoStack.pop();
  strokes.length = 0;
  strokes.push(...prev);
  redrawAll();
}
function redoAction(){
  if(!redoStack.length) return;
  undoStack.push(JSON.parse(JSON.stringify(strokes)));
  const next = redoStack.pop();
  strokes.length = 0;
  strokes.push(...next);
  redrawAll();
}
function savePNG(){ const link=document.createElement('a'); link.href=drawCanvas.toDataURL('image/png'); link.download='handdraw.png'; link.click();}
function exportSVG(){
  // build simple SVG paths from strokes using polyline approximation
  const rect = drawCanvas.getBoundingClientRect();
  const w = drawCanvas.width, h = drawCanvas.height;
  const svgParts = ['<svg xmlns="http://www.w3.org/2000/svg" width="'+w+'" height="'+h+'" viewBox="0 0 '+w+' '+h+'">'];
  for(const s of strokes){
    if(!s.points || s.points.length===0) continue;
    const d = s.points.map((p,i)=> (i===0?`M ${p.x} ${p.y}`:`L ${p.x} ${p.y}`)).join(' ');
    svgParts.push(`<path d="${d}" fill="none" stroke="${s.color}" stroke-width="${s.width}" stroke-linecap="round" stroke-linejoin="round" ${s.eraser?`opacity="0.35"`:''} />`);
  }
  svgParts.push('</svg>');
  const svg = svgParts.join('\n');
  const blob = new Blob([svg],{type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'handdraw.svg'; a.click();
  URL.revokeObjectURL(url);
}
function startReplay(){/* omitted for brevity, same as original */ }
function toggleTheme(){ darkTheme=!darkTheme; document.documentElement.style.setProperty('--bg-dark', darkTheme?'#071226':'#f7f9fb'); document.body.style.background = darkTheme?'linear-gradient(180deg,var(--bg-dark),#020617)':'linear-gradient(180deg,#f7f9fb,#e6eef8)';}

/* Gesture detection */
function isOpenHand(lm){
  let ext=0; const tips=[8,12,16,20], pips=[6,10,14,18];
  for(let i=0;i<4;i++) if(lm[tips[i]].y < lm[pips[i]].y) ext++;
  if(lm[4].x < lm[3].x) ext++;
  return ext>=4;
}
function isFist(lm){
  const wrist=lm[0]; let sum=0; const tips=[4,8,12,16,20];
  for(const t of tips){ const dx=lm[t].x - wrist.x; const dy=lm[t].y - wrist.y; sum+=Math.hypot(dx,dy);}
  return sum<0.45;
}

/* Draw utils */
function computeWidth(prev, curr, base){ const dx=curr.x-prev.x; const dy=curr.y-prev.y; const dist=Math.hypot(dx,dy); const dt=Math.max(1,curr.t-prev.t); const speed=dist/dt; const min=Math.max(1,base*0.28); const max=Math.max(1,base*1.12); const t=Math.min(1,speed/1.2); return Math.max(min,max*(1-t));}

/* Redraw all strokes (vector) onto the raster canvas */
function redrawAll(){
  if(!ctx) return;
  ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  for(const s of strokes){
    if(!s.points || s.points.length===0) continue;
    // simple replay: draw polyline and segments via Catmull-Rom chunks
    if(s.points.length===1){ const p=s.points[0]; ctx.beginPath(); ctx.arc(p.x,p.y, s.width/2, 0, Math.PI*2); ctx.fillStyle=s.color; ctx.fill(); continue; }
    if(s.points.length===2){ const p0=s.points[0], p1=s.points[1]; ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.strokeStyle = s.eraser ? '#000' : s.color; ctx.globalCompositeOperation = s.eraser ? 'destination-out' : 'source-over'; ctx.lineWidth = s.width; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.stroke(); ctx.globalCompositeOperation='source-over'; continue; }
    for(let i=3;i<s.points.length;i++){
      const seg=[s.points[i-3],s.points[i-2],s.points[i-1],s.points[i]];
      drawCatmullRomSegment(ctx, seg, s.color, s.width, s.eraser);
    }
  }
}

/* --------------------- HANDS SETUP --------------------- */
function setupHands(){
  const hands = new Hands({locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:0.68,minTrackingConfidence:0.6});
  hands.onResults(onResults);

  cameraObj = new Camera(video,{onFrame:async()=>{await hands.send({image:video});}, width:1280, height:720});
  cameraObj.start();
  running=true;
}

/* --------------------- ONRESULTS --------------------- */
function onResults(results){
  hud.clearRect(0,0,hudCanvas.width,hudCanvas.height);
  if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){ prevHud=null; prevPoint=null; statusText.textContent='Pausado — mão não detectada'; return;}
  const lm = results.multiHandLandmarks[0];

  // Canvas coordinates
  const tip=lm[8];
  const rawX = tip.x * drawCanvas.width;
  const rawY = tip.y * drawCanvas.height;
  // when mirror is active the video is visually flipped; invert X so HUD aligns with the visual
  const x = mirrorToggle.checked ? drawCanvas.width - rawX : rawX;
  const y = rawY;

  // Gestures
  const open=isOpenHand(lm);
  const fist=isFist(lm);

  // Update status
  if(open) statusText.textContent='Pausado — mão aberta';
  else if(erasing) statusText.textContent='Apagando';
  else statusText.textContent='Desenhando';

  // Punho para limpar
  const now = performance.now();
  if(fist){
    if(!closedStartTime) closedStartTime=now;
    else if(now-closedStartTime>1000){
      pushHistory(); ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); strokes.length=0; closedStartTime=null;
    }
  } else closedStartTime=null;

  // Determine drawing
  let drawNow=true;
  if(pinchToggle.checked){
    const thumb=lm[4];
    const d=Math.hypot(tip.x-thumb.x,tip.y-thumb.y);
    drawNow=d<0.055;
  }

  // HUD smoothing
  if(!prevHud) prevHud={x,y};
  prevHud.x=prevHud.x*0.7 + x*0.3; prevHud.y=prevHud.y*0.7 + y*0.3;
  hud.beginPath();
  hud.arc(prevHud.x,prevHud.y,12,0,Math.PI*2);
  hud.fillStyle='rgba(125,211,252,0.18)';
  hud.fill(); hud.lineWidth=1.5;
  hud.strokeStyle='rgba(125,211,252,0.5)';
  hud.stroke();

  if(open){ prevPoint=null; return; }

  // Start/continue stroke
  if(drawNow){
    const t=performance.now();
    const point={x:x,y:y,t:t};
    if(!currentStroke){ pushHistory(); currentStroke={points:[],color:colorEl.value,width:Number(thicknessEl.value),eraser:erasing,start:t}; strokes.push(currentStroke);}
    currentStroke.points.push(point);

    if(currentStroke.points.length>=4){
      const pts=currentStroke.points; const len=pts.length;
      const segmentPts=[pts[len-4],pts[len-3],pts[len-2],pts[len-1]];
      const w=computeWidth(segmentPts[2],segmentPts[3],currentStroke.width);
      drawCatmullRomSegment(ctx,segmentPts,currentStroke.color,w,currentStroke.eraser);
    } else if(currentStroke.points.length===2){
      const p0=currentStroke.points[0], p1=currentStroke.points[1];
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y);
      ctx.strokeStyle=currentStroke.eraser?'rgba(0,0,0,1)':currentStroke.color;
      ctx.lineWidth=currentStroke.width; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.globalCompositeOperation=currentStroke.eraser?'destination-out':'source-over';
      ctx.stroke(); ctx.globalCompositeOperation='source-over';
    }

    if(t-(lastTime||0)>250){ lastTime=t; } prevPoint=point;
  } else if(currentStroke){ currentStroke=null; prevPoint=null;}
}

/* Catmull-Rom draw segment */
function drawCatmullRomSegment(ctxLocal, pts, color, width, isEraser){
  if(pts.length<4) return;
  const p0=pts[0],p1=pts[1],p2=pts[2],p3=pts[3];
  const steps=12; ctxLocal.strokeStyle=color; ctxLocal.lineJoin='round'; ctxLocal.lineCap='round';
  ctxLocal.globalCompositeOperation=isEraser?'destination-out':'source-over';
  for(let s=0;s<steps;s++){
    const t0=s/steps, t1=(s+1)/steps;
    const x0=0.5*((-p0.x+3*p1.x-3*p2.x+p3.x)*t0*t0*t0 + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t0*t0 + (-p0.x+p2.x)*t0 + p1.x);
    const y0=0.5*((-p0.y+3*p1.y-3*p2.y+p3.y)*t0*t0*t0 + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t0*t0 + (-p0.y+p2.y)*t0 + p1.y);
    const x1=0.5*((-p0.x+3*p1.x-3*p2.x+p3.x)*t1*t1*t1 + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t1*t1 + (-p0.x+p2.x)*t1 + p1.x);
    const y1=0.5*((-p0.y+3*p1.y-3*p2.y+p3.y)*t1*t1*t1 + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t1*t1 + (-p0.y+p2.y)*t1 + p1.y);
    ctxLocal.beginPath(); ctxLocal.moveTo(x0,y0); ctxLocal.lineTo(x1,y1); ctxLocal.lineWidth=width; ctxLocal.stroke();
  }
  ctxLocal.globalCompositeOperation='source-over';
}

/* --------------------- CAMERA INIT --------------------- */
async function initCameraAndHands(){
  try{
    const stream=await navigator.mediaDevices.getUserMedia({video:true});
    video.srcObject=stream;
    video.onloadedmetadata=()=>{
      resizeCanvases();
      statusText.textContent='Câmera ativa ✅';
      setupHands();
    };
  } catch(err){
    statusText.textContent='Câmera bloqueada ❌';
    alert('Erro ao acessar câmera');
  }
}

initCameraAndHands();
</script>
</body>
</html>
